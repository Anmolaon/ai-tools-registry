{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "polar",
  "type": "registry:component",
  "title": "Polar Checkout",
  "description": "Embed a Polar Checkout button for a product.",
  "dependencies": ["zod", "ai"],
  "files": [
    {
      "path": "registry/ai-tools/tools/polar/tool.ts",
      "content": "import { z } from \"zod\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { Tool } from \"ai\"\n\nexport interface PolarMoney {\n  amount: number\n  currency: string\n}\n\nexport interface PolarProductInfo {\n  id?: string\n  name?: string\n  description?: string\n  price?: PolarMoney\n  imageUrl?: string\n  url?: string\n  checkoutUrl?: string\n}\n\nexport interface PolarCheckoutResult {\n  checkoutUrl: string\n  theme: \"light\" | \"dark\"\n  label: string\n  product?: PolarProductInfo\n  products?: PolarProductInfo[]\n}\n\nexport const polarTool: Tool = {\n  name: \"polarCheckout\",\n  description:\n    \"Find a product and return a checkout configuration (Polar provider).\",\n  inputSchema: z.object({\n    // User's intent\n    query: z.string().min(2).describe(\"Product the user is looking for\"),\n    provider: z.enum([\"polar\"]).default(\"polar\"),\n    // Checkout button appearance\n    checkoutUrl: z\n      .string()\n      .url()\n      .default(\n        \"https://buy.polar.sh/polar_cl_PytpHds6i4zVimGcDzVnDRNS7OmAkhnurEPPJ2d9UbN\"\n      ),\n    theme: z.enum([\"light\", \"dark\"]).default(\"dark\"),\n    label: z.string().default(\"Purchase\"),\n    // Optional: fetch product info from a public/product API\n    // Provide a full URL template or endpoint for fetching a product\n    // e.g. https://api.polar.sh/v1/products/{id}\n    searchApiUrl: z\n      .string()\n      .url()\n      .optional()\n      .describe(\"Returns an array of products\"),\n    productApiUrl: z\n      .string()\n      .url()\n      .optional()\n      .describe(\"Template or base for fetching a single product by id\"),\n    productId: z.string().optional(),\n    catalog: z\n      .array(\n        z.object({\n          id: z.string().optional(),\n          name: z.string().optional(),\n          description: z.string().optional(),\n          imageUrl: z.string().url().optional(),\n          url: z.string().url().optional(),\n          checkoutUrl: z.string().url().optional(),\n          price: z\n            .object({ amount: z.number(), currency: z.string() })\n            .optional(),\n        })\n      )\n      .optional(),\n    // Load products from a checkout link\n    checkoutProducts: z.boolean().default(false),\n    // Optional fallback API template for checkout lookup: e.g. https://api.polar.sh/v1/checkouts/{id}\n    checkoutApiUrl: z.string().url().optional(),\n  }),\n  execute: async ({\n    query,\n    provider,\n    checkoutUrl,\n    theme,\n    label,\n    searchApiUrl,\n    productApiUrl,\n    productId,\n    catalog,\n    checkoutProducts,\n    checkoutApiUrl,\n  }: {\n    query: string\n    provider: \"polar\"\n    checkoutUrl: string\n    theme: \"light\" | \"dark\"\n    label: string\n    searchApiUrl?: string\n    productApiUrl?: string\n    productId?: string\n    catalog?: PolarProductInfo[]\n    checkoutProducts?: boolean\n    checkoutApiUrl?: string\n  }): Promise<PolarCheckoutResult> => {\n    const optionalImport = async (name: string) => {\n      try {\n        // Avoid static analysis by Turbopack/Webpack\n        // eslint-disable-next-line no-new-func\n        const dynamicImport = new Function(\"n\", \"return import(n)\") as (\n          n: string\n        ) => Promise<any>\n        return await dynamicImport(name)\n      } catch {\n        return null\n      }\n    }\n    let products: PolarProductInfo[] = Array.isArray(catalog)\n      ? [...catalog]\n      : []\n\n    // Helper: parse checkout id from a Polar link\n    const parseCheckoutId = (url: string): string | undefined => {\n      const m = url.match(/polar_cl_[A-Za-z0-9]+/)\n      return m?.[0]\n    }\n\n    // Provider: Polar (Node SDK if available)\n    if (provider === \"polar\" && process.env.POLAR_API_TOKEN) {\n      try {\n        const sdk: any = await optionalImport(\"@polar-sh/sdk\")\n        if (sdk) {\n          const client = sdk.createClient\n            ? sdk.createClient({ accessToken: process.env.POLAR_API_TOKEN })\n            : sdk.Polar\n              ? new sdk.Polar({ accessToken: process.env.POLAR_API_TOKEN })\n              : sdk.Client\n                ? new sdk.Client({ accessToken: process.env.POLAR_API_TOKEN })\n                : null\n          if (client) {\n            // Try a few likely search shapes; normalize to array\n            const searchRes =\n              (await client.products?.search?.({ query }).catch(() => null)) ||\n              (await client.products?.list?.({ q: query }).catch(() => null)) ||\n              (await client.search?.products?.({ query }).catch(() => null))\n            const items: any[] = Array.isArray(searchRes?.items)\n              ? searchRes.items\n              : Array.isArray(searchRes?.data)\n                ? searchRes.data\n                : Array.isArray(searchRes?.products)\n                  ? searchRes.products\n                  : []\n            for (const item of items) {\n              products.push({\n                id: item?.id,\n                name: item?.name,\n                description: item?.description,\n                imageUrl: item?.image_url ?? item?.imageUrl,\n                url: item?.url,\n                checkoutUrl: item?.checkout_url ?? item?.checkoutUrl,\n                price:\n                  typeof item?.price?.amount === \"number\" &&\n                  typeof item?.price?.currency === \"string\"\n                    ? {\n                        amount: item.price.amount,\n                        currency: item.price.currency,\n                      }\n                    : undefined,\n              })\n            }\n          }\n        }\n      } catch {\n        // Ignore SDK errors; proceed with other discovery methods\n      }\n    }\n    // Option A.2: Checkout link â†’ fetch products contained in checkout\n    if (checkoutProducts) {\n      const cid = parseCheckoutId(checkoutUrl)\n      if (cid) {\n        // Try SDK first\n        try {\n          const sdk: any = await optionalImport(\"@polar-sh/sdk\")\n          if (sdk) {\n            const client = sdk.createClient\n              ? sdk.createClient({ accessToken: process.env.POLAR_API_TOKEN })\n              : sdk.Polar\n                ? new sdk.Polar({ accessToken: process.env.POLAR_API_TOKEN })\n                : sdk.Client\n                  ? new sdk.Client({ accessToken: process.env.POLAR_API_TOKEN })\n                  : null\n            const chk =\n              (await client?.checkouts?.get?.({ id: cid }).catch(() => null)) ||\n              (await client?.checkout?.get?.({ id: cid }).catch(() => null))\n            const lines: any[] = Array.isArray(chk?.items)\n              ? chk.items\n              : Array.isArray(chk?.line_items)\n                ? chk.line_items\n                : Array.isArray(chk?.products)\n                  ? chk.products\n                  : []\n            for (const li of lines) {\n              products.push({\n                id: li?.product_id ?? li?.id,\n                name: li?.name ?? li?.product?.name,\n                description: li?.description ?? li?.product?.description,\n                price:\n                  typeof li?.price?.amount === \"number\" &&\n                  typeof li?.price?.currency === \"string\"\n                    ? { amount: li.price.amount, currency: li.price.currency }\n                    : undefined,\n                imageUrl: li?.image_url ?? li?.product?.image_url,\n                url: li?.url ?? li?.product?.url,\n              })\n            }\n          }\n        } catch {\n          // REST template fallback\n          if (checkoutApiUrl) {\n            const url = checkoutApiUrl.includes(\"{id}\")\n              ? checkoutApiUrl.replace(\"{id}\", encodeURIComponent(cid))\n              : `${checkoutApiUrl}${checkoutApiUrl.endsWith(\"/\") ? \"\" : \"/\"}${encodeURIComponent(cid)}`\n            try {\n              const res = await fetch(url, {\n                headers: {\n                  ...(process.env.POLAR_API_TOKEN\n                    ? { Authorization: `Bearer ${process.env.POLAR_API_TOKEN}` }\n                    : {}),\n                },\n                cache: \"no-store\",\n              })\n              if (res.ok) {\n                const data = await res.json()\n                const lines: any[] = Array.isArray(data?.items)\n                  ? data.items\n                  : Array.isArray(data?.line_items)\n                    ? data.line_items\n                    : []\n                for (const li of lines) {\n                  products.push({\n                    id: li?.product_id ?? li?.id,\n                    name: li?.name ?? li?.product?.name,\n                    description: li?.description ?? li?.product?.description,\n                    price:\n                      typeof li?.price?.amount === \"number\" &&\n                      typeof li?.price?.currency === \"string\"\n                        ? { amount: li.price.amount, currency: li.price.currency }\n                        : undefined,\n                    imageUrl: li?.image_url ?? li?.product?.image_url,\n                    url: li?.url ?? li?.product?.url,\n                  })\n                }\n              }\n            } catch {\n              // ignore\n            }\n          }\n        }\n      }\n    }\n    // Option A: search endpoint returns an array of products\n    if (searchApiUrl) {\n      try {\n        const res = await fetch(searchApiUrl, { cache: \"no-store\" })\n        if (res.ok) {\n          const data = await res.json()\n          const arr = Array.isArray(data)\n            ? data\n            : Array.isArray(data?.data)\n              ? data.data\n              : []\n          for (const item of arr) {\n            products.push({\n              id: item?.id,\n              name: item?.name,\n              description: item?.description,\n              price:\n                typeof item?.price?.amount === \"number\" &&\n                typeof item?.price?.currency === \"string\"\n                  ? { amount: item.price.amount, currency: item.price.currency }\n                  : undefined,\n              imageUrl: item?.image_url ?? item?.imageUrl,\n              url: item?.url,\n              checkoutUrl: item?.checkout_url ?? item?.checkoutUrl,\n            })\n          }\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // Option B: fetch a specific product by id\n    if (productApiUrl && productId) {\n      // Build URL (support templated {id} or query parameter)\n      const url = productApiUrl.includes(\"{id}\")\n        ? productApiUrl.replace(\"{id}\", encodeURIComponent(productId))\n        : `${productApiUrl}${productApiUrl.endsWith(\"/\") ? \"\" : \"/\"}${encodeURIComponent(productId)}`\n      try {\n        const res = await fetch(url, {\n          headers: {\n            // If a server token is available, include it. Optional.\n            ...(process.env.POLAR_API_TOKEN\n              ? { Authorization: `Bearer ${process.env.POLAR_API_TOKEN}` }\n              : {}),\n          },\n          // Avoid caching to get latest pricing when used server-side.\n          cache: \"no-store\",\n        })\n        if (res.ok) {\n          const data = await res.json()\n          // Be permissive to accommodate different API shapes\n          const money = (\n            amount: unknown,\n            currency: unknown\n          ): PolarMoney | undefined =>\n            typeof amount === \"number\" && typeof currency === \"string\"\n              ? { amount, currency }\n              : undefined\n          products.push({\n            id: (data?.id as string) ?? (data?.data?.id as string),\n            name: (data?.name as string) ?? (data?.data?.name as string),\n            description:\n              (data?.description as string) ??\n              (data?.data?.description as string),\n            price:\n              money(data?.price?.amount, data?.price?.currency) ||\n              money(data?.data?.price?.amount, data?.data?.price?.currency),\n            imageUrl:\n              (data?.image_url as string) ??\n              (data?.imageUrl as string) ??\n              (data?.data?.image_url as string),\n            url: (data?.url as string) ?? (data?.data?.url as string),\n            checkoutUrl:\n              (data?.checkout_url as string) ??\n              (data?.data?.checkout_url as string),\n          })\n        }\n      } catch {\n        // Swallow network errors; still return checkout config.\n      }\n    }\n\n    // Select best match against query\n    const q = query.toLowerCase().trim()\n    const tokens = q.split(/\\s+/g).filter(Boolean)\n    const score = (p: PolarProductInfo) => {\n      const hay = `${p.name ?? \"\"} ${p.description ?? \"\"}`.toLowerCase()\n      let s = 0\n      for (const t of tokens) {\n        if (hay.includes(t)) s += 2\n      }\n      if ((p.name ?? \"\").toLowerCase().startsWith(tokens[0] ?? \"\")) s += 1\n      return s\n    }\n    products = products.filter((p) => p.name ?? p.description)\n    products.sort((a, b) => score(b) - score(a))\n    const best = products[0]\n\n    // Try to create a checkout via SDK if we found a product id and have a token\n    let url = best?.checkoutUrl || checkoutUrl\n    if (provider === \"polar\" && best?.id && process.env.POLAR_API_TOKEN) {\n      try {\n        const sdk: any = await optionalImport(\"@polar-sh/sdk\")\n        if (sdk) {\n          const client = sdk.createClient\n            ? sdk.createClient({ accessToken: process.env.POLAR_API_TOKEN })\n            : sdk.Polar\n              ? new sdk.Polar({ accessToken: process.env.POLAR_API_TOKEN })\n              : sdk.Client\n                ? new sdk.Client({ accessToken: process.env.POLAR_API_TOKEN })\n                : null\n          const checkoutRes =\n            (await client?.checkouts\n              ?.create?.({ productId: best.id })\n              .catch(() => null)) ||\n            (await client?.checkout\n              ?.create?.({ product_id: best.id })\n              .catch(() => null))\n          url = checkoutRes?.url || url\n        }\n      } catch {\n        // ignore; fall back to provided URL\n      }\n    }\n\n    const unique = (arr: PolarProductInfo[]) => {\n      const seen = new Set<string>()\n      const out: PolarProductInfo[] = []\n      for (const p of arr) {\n        const k = p.id || `${p.name}-${p.price?.amount}-${p.price?.currency}`\n        if (k && !seen.has(k)) {\n          seen.add(k)\n          out.push(p)\n        }\n      }\n      return out\n    }\n    return { checkoutUrl: url, theme, label, product: best, products: unique(products) }\n  },\n}\n\nexport default polarTool\n",
      "type": "registry:file",
      "target": "~/ai/tools/polar/tool.ts"
    },
    {
      "path": "registry/ai-tools/tools/polar/component.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport type { PolarCheckoutResult } from \"./tool\"\n\nexport function PolarCheckout({ data }: { data: PolarCheckoutResult }) {\n  React.useEffect(() => {\n    const existing = document.querySelector(\n      'script[src*=\"@polar-sh/checkout@0.1/dist/embed.global.js\"]'\n    ) as HTMLScriptElement | null\n    if (existing) return\n    const s = document.createElement(\"script\")\n    s.src =\n      \"https://cdn.jsdelivr.net/npm/@polar-sh/checkout@0.1/dist/embed.global.js\"\n    s.defer = true\n    s.setAttribute(\"data-auto-init\", \"true\")\n    document.body.appendChild(s)\n    return () => {\n      // leave the script in place to avoid reloading on route changes\n    }\n  }, [])\n\n  const p = data.product\n  const list = data.products && data.products.length > 1 ? data.products : undefined\n\n  return (\n    <div className=\"w-full max-w-sm\">\n      {list ? (\n        <div className=\"mb-3 rounded-md border p-3\">\n          <div className=\"text-sm font-medium mb-1\">Included Products</div>\n          <ul className=\"space-y-1 text-sm\">\n            {list.map((it, idx) => (\n              <li key={it.id ?? idx} className=\"flex items-center justify-between\">\n                <span className=\"truncate mr-2\">{it.name ?? \"Product\"}</span>\n                {it.price ? (\n                  <span className=\"text-xs text-muted-foreground\">\n                    {(it.price.amount / 100).toLocaleString(undefined, {\n                      style: \"currency\",\n                      currency: it.price.currency,\n                    })}\n                  </span>\n                ) : null}\n              </li>\n            ))}\n          </ul>\n        </div>\n      ) : p ? (\n        <div className=\"mb-3 rounded-md border p-3\">\n          <div className=\"text-sm font-medium\">{p.name ?? \"Product\"}</div>\n          {p.description ? (\n            <div className=\"mt-1 text-xs text-muted-foreground line-clamp-3\">\n              {p.description}\n            </div>\n          ) : null}\n          {p.price ? (\n            <div className=\"mt-2 text-sm\">\n              {(p.price.amount / 100).toLocaleString(undefined, {\n                style: \"currency\",\n                currency: p.price.currency,\n              })}\n            </div>\n          ) : null}\n        </div>\n      ) : null}\n      <a\n        href={data.checkoutUrl}\n        data-polar-checkout\n        data-polar-checkout-theme={data.theme}\n        className=\"inline-flex items-center justify-center rounded-md border px-4 py-2 text-sm font-medium hover:opacity-90\"\n      >\n        {data.label}\n      </a>\n      <div className=\"mt-2 text-xs text-muted-foreground\">\n        Powered by Polar Checkout\n      </div>\n    </div>\n  )\n}\n\nexport default PolarCheckout\n",
      "type": "registry:file",
      "target": "~/ai/tools/polar/component.tsx"
    }
  ]
}
